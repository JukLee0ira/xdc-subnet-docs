"use strict";(self.webpackChunkxdc_subnet_docs=self.webpackChunkxdc_subnet_docs||[]).push([[777],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),c=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=c(e.components);return a.createElement(d.Provider,{value:n},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=c(t),u=r,m=h["".concat(d,".").concat(u)]||h[u]||p[u]||o;return t?a.createElement(m,i(i({ref:n},l),{},{components:t})):a.createElement(m,i({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[h]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4397:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={sidebar_label:"5. Grand Master Manual: CLI",sidebar_position:6},i="Grand Master Manual: CLI",s={unversionedId:"deployment/grand_master_manual_cli",id:"deployment/grand_master_manual_cli",title:"Grand Master Manual: CLI",description:"Overview",source:"@site/docs/deployment/5_grand_master_manual_cli.md",sourceDirName:"deployment",slug:"/deployment/grand_master_manual_cli",permalink:"/xdc-subnet-docs/deployment/grand_master_manual_cli",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_label:"5. Grand Master Manual: CLI",sidebar_position:6},sidebar:"defaultSidebar",previous:{title:"4. Launch Stats UI",permalink:"/xdc-subnet-docs/deployment/stats_server"}},d={},c=[{value:"Overview",id:"overview",level:2},{value:"Propose",id:"propose",level:2},{value:"Resign",id:"resign",level:2},{value:"Vote",id:"vote",level:2},{value:"Unvote",id:"unvote",level:2},{value:"Withdraw",id:"withdraw",level:2},{value:"Instruction",id:"instruction",level:2},{value:"Send a transaction of propose:",id:"send-a-transaction-of-propose",level:3},{value:"Send a transaction of resign:",id:"send-a-transaction-of-resign",level:3},{value:"Send a transaction for vote:",id:"send-a-transaction-for-vote",level:3},{value:"Send a transaction for unvote:",id:"send-a-transaction-for-unvote",level:3},{value:"Send a transaction for withdraw:",id:"send-a-transaction-for-withdraw",level:3}],l={toc:c},h="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(h,(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"grand-master-manual-cli"},"Grand Master Manual: CLI"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The master nodes are managed by the XDCValidator smart contract. The contract records the list of master nodes and provide functions to be called by the grand master to make changes to the list. The functions include propose, resign, vote, unvote, and withdraw, and the following sections will introduce them in details."),(0,r.kt)("p",null,"At the gap block (block number ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," such that ",(0,r.kt)("inlineCode",{parentName:"p"},"n%Epoch=Epoch-Gap"),"), the XDC program will query the list of master nodes from the contract and will store the list in a snapshot. Then at the next epoch switch block (block round ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," and parent block round ",(0,r.kt)("inlineCode",{parentName:"p"},"r_parent")," such that ",(0,r.kt)("inlineCode",{parentName:"p"},"r, r_parent")," are across two epochs) that is at least ",(0,r.kt)("inlineCode",{parentName:"p"},"Gap")," blocks after the aforementioned gap block, the new candidate list be chosen from the first 108 nodes (ordered by cap) from the list in the snapshot and they become the master nodes for the following epoch."),(0,r.kt)("p",null,"The following sections introduce the smart contract functions that the grand master can call to make changes to the master nodes."),(0,r.kt)("h2",{id:"propose"},"Propose"),(0,r.kt)("p",null,"Function format: ",(0,r.kt)("inlineCode",{parentName:"p"},"propose(address _candidate)"),". That is, the function takes the address of the proposed candidate as input."),(0,r.kt)("p",null,"The grand master can propose any non-candidate address and make it become a candidate. The owner will be the grand master and the candidate's cap will be the value transfered by this transaction. Finally, the contract emits a ",(0,r.kt)("inlineCode",{parentName:"p"},"Propose")," event."),(0,r.kt)("p",null,"Only the grand master can call this function (modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"onlyGrandMaster"),") and the value of the transaction has to be no less than a constant ",(0,r.kt)("inlineCode",{parentName:"p"},"minCandidateCap"),". This means the grand master should have balance no less than ",(0,r.kt)("inlineCode",{parentName:"p"},"minCandidateCap"),"."),(0,r.kt)("h2",{id:"resign"},"Resign"),(0,r.kt)("p",null,"Function format: ",(0,r.kt)("inlineCode",{parentName:"p"},"resign(address _candidate)"),". That is, the function takes the candidate's address as input."),(0,r.kt)("p",null,"The grand master (also the owner of the candidate) calls this function to resign a candidate. More specifically, the contract marks the candidate as no longer active, removes the candidate from the list of candidates, and sets up a refund mechanism for the owner. The contract records the withdraw block number, which is current number plus a constant delay ",(0,r.kt)("inlineCode",{parentName:"p"},"candidateWithdrawDelay"),". It also records the withdraw index for the caller, that is, the index of withdraw entries this caller possesses. Finally, it emits a ",(0,r.kt)("inlineCode",{parentName:"p"},"Resign")," event."),(0,r.kt)("p",null,"Only the owner (that is, the grand master) can call this function (modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"onlyOwner"),")."),(0,r.kt)("p",null,"As for how to withdraw the refund, please refer to the Withdraw section."),(0,r.kt)("h2",{id:"vote"},"Vote"),(0,r.kt)("p",null,"Function format: ",(0,r.kt)("inlineCode",{parentName:"p"},"vote(address _candidate)"),". That is, the function takes the address of the candidate being voted for as input."),(0,r.kt)("p",null,"The grand master can vote a candidate to increase its cap by transftering a certain amount of value in the transaction. Finally, the contract emits a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vote")," event."),(0,r.kt)("p",null,"Only the grand master can call this function (modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"onlyGrandMaster"),") and the value of the transaction has to be no less than a constant ",(0,r.kt)("inlineCode",{parentName:"p"},"minVoterCap"),". In addition, the address must already be a candidate."),(0,r.kt)("h2",{id:"unvote"},"Unvote"),(0,r.kt)("p",null,"Function format: ",(0,r.kt)("inlineCode",{parentName:"p"},"unvote(address _candidate, uint256 _cap)"),". That is, the function takes the candidate's address and the amount of cap to be unvoted as inputs."),(0,r.kt)("p",null,"The grand master call this function to reduce its cap for a candidate. More specifically, the contract can subtract the unvoted cap from the candidate's cap and set up a refund mechanism by recording the unvoted cap to be withdrawn after a certain delay. It records the withdraw block number, which is current number plus a constant delay ",(0,r.kt)("inlineCode",{parentName:"p"},"voterWithdrawDelay"),". It also records the withdraw index for the caller, that is, the index of withdraw entries this caller possesses. Finally, it emits an ",(0,r.kt)("inlineCode",{parentName:"p"},"Unvote")," event."),(0,r.kt)("p",null,"Only the valid voter (that is, the grand master) can call this function (modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"onlyValidVote"),"). In addition, the candidate must have voter cap no less than ",(0,r.kt)("inlineCode",{parentName:"p"},"_cap"),"."),(0,r.kt)("h2",{id:"withdraw"},"Withdraw"),(0,r.kt)("p",null,"Function format: ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw(uint256 _blockNumber, uint _index)"),". That is, the function takes the block number and index of the withdrawal as inputs."),(0,r.kt)("p",null,"This function allows users to withdraw their refunded caps after a certain delay. It checks the validity of the withdrawal based on the provided block number and index. If the withdrawal is valid, the function transfers the withdrawn cap to the caller and emits a ",(0,r.kt)("inlineCode",{parentName:"p"},"Withdraw")," event."),(0,r.kt)("p",null,"The current block number must be no less than ",(0,r.kt)("inlineCode",{parentName:"p"},"_blockNumber")," in order to make the withdraw."),(0,r.kt)("h2",{id:"instruction"},"Instruction"),(0,r.kt)("p",null,"This section provides the nodejs codes for the grand master to call the functions. First, you need the code to import the dependencies and prepare some variables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const { Web3 } = require('web3');\nconst abi = require('ethereumjs-abi');\nconst EthereumTx = require('ethereumjs-tx').Transaction\n\nconst grandPrivateKey = Buffer.from(\n        'your grand master private key in hex format',\n        'hex',\n    );\nconst grandAddr = '0x your grand master address in hex format';\nconst candidate = '0x the candidate address';\n")),(0,r.kt)("h3",{id:"send-a-transaction-of-propose"},"Send a transaction of propose:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"async function main () {\n    const web3 = new Web3('http://ip:port');\n    \n    const nonce = await web3.eth.getTransactionCount(grandAddr);\n    const encodedData = '0x' + abi.simpleEncode(\"propose(address)\", candidate).toString('hex');\n    const txParams = {\n        nonce: Number(nonce),\n        gasPrice: 250000000, // change it if you like\n        gasLimit: 220000, // change it if you like\n        to: '0x0000000000000000000000000000000000000088',\n        value: '0x84595161401484a000000',\n        data: encodedData,\n    };\n    const tx = new EthereumTx(txParams, {'chain':'mainnet', 'hardfork': 'homestead'}); // hardfork homestead is critical to make it work!\n    tx.sign(grandPrivateKey);\n    const serializedTx = '0x' + tx.serialize().toString('hex');\n    console.log('propose for candidate', candidate, 'tx params', txParams, 'serialized', serializedTx);\n\n    web3.eth.sendSignedTransaction(serializedTx)\n    .on('transactionHash',(hash) => {\n        console.log('txHash:', hash)\n    })\n    .on('error', console.error);\n\n    console.log(\"send tx finish\");\n}\n\nmain().then(console.log).catch(console.error)\n")),(0,r.kt)("h3",{id:"send-a-transaction-of-resign"},"Send a transaction of resign:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"async function main () {\n    const web3 = new Web3('http://ip:port');\n    \n    const nonce = await web3.eth.getTransactionCount(grandAddr);\n    const encodedData = '0x' + abi.simpleEncode(\"resign(address)\", candidate).toString('hex');\n    const txParams = {\n        nonce: Number(nonce),\n        gasPrice: 250000000, // change it if you like\n        gasLimit: 220000, // change it if you like\n        to: '0x0000000000000000000000000000000000000088',\n        value: '0x0',\n        data: encodedData,\n    };\n    const tx = new EthereumTx(txParams, {'chain':'mainnet', 'hardfork': 'homestead'}); // hardfork homestead is critical to make it work!\n    tx.sign(grandPrivateKey);\n    const serializedTx = '0x' + tx.serialize().toString('hex');\n    console.log('resign for candidate', candidate, 'tx params', txParams, 'serialized', serializedTx);\n\n    web3.eth.sendSignedTransaction(serializedTx)\n    .on('transactionHash',(hash) => {\n        console.log('txHash:', hash)\n    })\n    .on('error', console.error);\n\n    console.log(\"send tx finish\");\n}\n\nmain().then(console.log).catch(console.error)\n")),(0,r.kt)("h3",{id:"send-a-transaction-for-vote"},"Send a transaction for vote:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"async function main () {\n    const web3 = new Web3('http://ip:port');\n    \n    const nonce = await web3.eth.getTransactionCount(grandAddr);\n    const encodedData = '0x' + abi.simpleEncode(\"vote(address)\", candidate).toString('hex');\n    const txParams = {\n        nonce: Number(nonce),\n        gasPrice: 250000000, // change it if you like\n        gasLimit: 220000, // change it if you like\n        to: '0x0000000000000000000000000000000000000088',\n        value: '0x54b40b1f852bda00000',\n        data: encodedData,\n    };\n    const tx = new EthereumTx(txParams, {'chain':'mainnet', 'hardfork': 'homestead'}); // hardfork homestead is critical to make it work!\n    tx.sign(grandPrivateKey);\n    const serializedTx = '0x' + tx.serialize().toString('hex');\n    console.log('vote for candidate', candidate, 'tx params', txParams, 'serialized', serializedTx);\n\n    web3.eth.sendSignedTransaction(serializedTx)\n    .on('transactionHash',(hash) => {\n        console.log('txHash:', hash)\n    })\n    .on('error', console.error);\n\n    console.log(\"send tx finish\");\n}\n\nmain().then(console.log).catch(console.error)\n")),(0,r.kt)("h3",{id:"send-a-transaction-for-unvote"},"Send a transaction for unvote:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const unvoteCap = 25000000000000000000000; // change it if you like\nasync function main () {\n    const web3 = new Web3('http://ip:port');\n    \n    const nonce = await web3.eth.getTransactionCount(grandAddr);\n    const encodedData = '0x' + abi.simpleEncode(\"unvote(address,uint256)\", candidate, unvoteCap).toString('hex');\n    const txParams = {\n        nonce: Number(nonce),\n        gasPrice: 250000000, // change it if you like\n        gasLimit: 220000, // change it if you like\n        to: '0x0000000000000000000000000000000000000088',\n        value: '0x0',\n        data: encodedData,\n    };\n    const tx = new EthereumTx(txParams, {'chain':'mainnet', 'hardfork': 'homestead'}); // hardfork homestead is critical to make it work!\n    tx.sign(grandPrivateKey);\n    const serializedTx = '0x' + tx.serialize().toString('hex');\n    console.log('unvote for candidate', candidate, 'tx params', txParams, 'serialized', serializedTx);\n\n    web3.eth.sendSignedTransaction(serializedTx)\n    .on('transactionHash',(hash) => {\n        console.log('txHash:', hash)\n    })\n    .on('error', console.error);\n\n    console.log(\"send tx finish\");\n}\n\nmain().then(console.log).catch(console.error)\n")),(0,r.kt)("h3",{id:"send-a-transaction-for-withdraw"},"Send a transaction for withdraw:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const blockNumber = 0; // change it to the withdraw block number (get it from getWithdrawBlockNumbers())\nconst index = 0; // change it to the withdraw index (get it from getWithdrawBlockNumbers())\nasync function main () {\n    const web3 = new Web3('http://ip:port');\n    \n    const nonce = await web3.eth.getTransactionCount(grandAddr);\n    const encodedData = '0x' + abi.simpleEncode(\"withdraw(uint256,uint)\", blockNumber, index).toString('hex');\n    const txParams = {\n        nonce: Number(nonce),\n        gasPrice: 250000000, // change it if you like\n        gasLimit: 220000, // change it if you like\n        to: '0x0000000000000000000000000000000000000088',\n        value: '0x0',\n        data: encodedData,\n    };\n    const tx = new EthereumTx(txParams, {'chain':'mainnet', 'hardfork': 'homestead'}); // hardfork homestead is critical to make it work!\n    tx.sign(grandPrivateKey);\n    const serializedTx = '0x' + tx.serialize().toString('hex');\n    console.log('withdraw at number', blockNumber, 'tx params', txParams, 'serialized', serializedTx);\n\n    web3.eth.sendSignedTransaction(serializedTx)\n    .on('transactionHash',(hash) => {\n        console.log('txHash:', hash)\n    })\n    .on('error', console.error);\n\n    console.log(\"send tx finish\");\n}\n\nmain().then(console.log).catch(console.error)\n")))}p.isMDXComponent=!0}}]);