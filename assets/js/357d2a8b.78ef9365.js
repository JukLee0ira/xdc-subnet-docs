"use strict";(self.webpackChunkxdc_subnet_docs=self.webpackChunkxdc_subnet_docs||[]).push([[822],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=s(n),k=i,u=m["".concat(c,".").concat(k)]||m[k]||d[k]||r;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=k;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},9125:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:1},o="Design",l={unversionedId:"compoments/parentchain_smart_contract/design",id:"compoments/parentchain_smart_contract/design",title:"Design",description:"Overview",source:"@site/docs/compoments/parentchain_smart_contract/design.md",sourceDirName:"compoments/parentchain_smart_contract",slug:"/compoments/parentchain_smart_contract/design",permalink:"/xdc-subnet-docs/compoments/parentchain_smart_contract/design",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Parent Chain Smart Contract",permalink:"/xdc-subnet-docs/category/parent-chain-smart-contract"},next:{title:"Specs",permalink:"/xdc-subnet-docs/compoments/parentchain_smart_contract/spec"}},c={},s=[{value:"Overview",id:"overview",level:2},{value:"Specifics",id:"specifics",level:2},{value:"Checkpoint",id:"checkpoint",level:3},{value:"Lite Checkpoint",id:"lite-checkpoint",level:3}],p={toc:s},m="wrapper";function d(e){let{components:t,...r}=e;return(0,i.kt)(m,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"design"},"Design"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"The primary function of the parent chain smart contract is to receive block data from the subnet node, verify it, and store it. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Noteworthy aspects:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Every block data received will be verified to ensure the signature is signed by validators and has passed with 2/3 of the votes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the gap block occurring in the middle of each epoch, a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," may appear, which will be selected for temporary storage.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In each epoch block, a ",(0,i.kt)("inlineCode",{parentName:"p"},"current")," may appear, which will choose the ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," selected during the gap as validators from the current block to the next epoch.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Only three consecutive blocks of ",(0,i.kt)("inlineCode",{parentName:"p"},"roundNumber")," can confirm the previous block, and ",(0,i.kt)("inlineCode",{parentName:"p"},"mainnetNum")," will change from -1 to ",(0,i.kt)("inlineCode",{parentName:"p"},"block.number")," once the block is committed."))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Overview",src:n(8344).Z,width:"1366",height:"800"})),(0,i.kt)("h2",{id:"specifics"},"Specifics"),(0,i.kt)("h3",{id:"checkpoint"},"Checkpoint"),(0,i.kt)("p",null,"The Checkpoint contract implements a blockchain checkpoint system, which verifies and stores block header information for subnetworks. Here are some key functions and features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The contract defines several data structures, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Header"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"HeaderInfo"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Validators")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BlockLite"),". These structures are used to store block header information, validator information, and more.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The contract employs several mappings and other variables to track the current block header tree, committed blocks, validator set, latest block, and so forth.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The contract's constructor receives the initial validator set, the genesis block header, the first block header, etc., as parameters and initializes the contract state based on these.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"receiveHeader")," function allows users to submit new block headers. This function will verify the meta information of the block header (like block number, parent block hash, etc.), the signature certificate, and update the block's submission status when specific conditions are met.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"setLookup"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"setCommittedStatus"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"checkUniqueness"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"checkCommittedStatus")," are used to update or check the contract's internal status.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"getHeader"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"getHeaderByNumber"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"getLatestBlocks")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"getCurrentValidators")," enable users to query block header information, validator sets, etc.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"splitSignature")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"recoverSigner")," functions are used to recover the signer's address from the signature, which is necessary for verifying the block header signature."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Logic Flow:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Checkpoint uses the following parameters for contract construction:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"address[]  initial_validator_set "),": List of initial validator addresses"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bytes genesis_header"),": block0HexRLP"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bytes block1_header"),": block1HexRLP"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"uint64 gap"),": GAP block number on public chain"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"uint64 epoch"),": EPOCH block number on public chain"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Relayers need to fetch every block data from the subnet node.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Users can retrieve the information of each block using methods such as ",(0,i.kt)("inlineCode",{parentName:"p"},"getHeader"),"."))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Checkpoint",src:n(2714).Z,width:"2238",height:"924"})),(0,i.kt)("h3",{id:"lite-checkpoint"},"Lite Checkpoint"),(0,i.kt)("p",null,"Lite Checkpoint is a lightweight block header checkpoint. It implements several functions, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Setting the initial validator set and related parameters during contract initialization."),(0,i.kt)("li",{parentName:"ul"},"Checking whether the submitted block header meets the requirements."),(0,i.kt)("li",{parentName:"ul"},"Receiving and processing submitted block headers."),(0,i.kt)("li",{parentName:"ul"},"Submitting the block header and block header by block number."),(0,i.kt)("li",{parentName:"ul"},"Retrieving uncommitted block header information."),(0,i.kt)("li",{parentName:"ul"},"Accessing specific block header information."),(0,i.kt)("li",{parentName:"ul"},"Fetching the current and next round of epoch blocks according to the index."),(0,i.kt)("li",{parentName:"ul"},"Getting the latest block information."),(0,i.kt)("li",{parentName:"ul"},"Accessing the current set of validators.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Logic Flow:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Lite Checkpoint uses the following parameters for contract construction:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"address[]  initialValidatorSet "),": List of initial validator addresses"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bytes block1"),": block1HexRLP"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"uint64 gap"),": GAP block number on public chain"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"uint64 epoch"),": EPOCH block number on public chain"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Relayers only need to fetch gap/epoch block data and fetch the following consecutive ",(0,i.kt)("inlineCode",{parentName:"p"},"roundNumber")," blocks to confirm the signed gap/epoch block from the subnet node.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Users can get gap/epoch block information from methods such as ",(0,i.kt)("inlineCode",{parentName:"p"},"getHeader"),"."))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Lite Checkpoint",src:n(114).Z,width:"2204",height:"932"})))}d.isMDXComponent=!0},2714:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/sc-checkpoint-36d3f42583ecf743412f5f6b1b1cc943.jpg"},114:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/sc-litecheckpoint-cbb2a69680785f10c23607a35edf201d.jpg"},8344:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/sc-overview-51bb08c762cab3e54f221fc92569c874.jpg"}}]);